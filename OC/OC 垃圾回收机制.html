<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>“OC 垃圾回收机制" - </title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/"></a>
    &nbsp;&#187;&nbsp;
    <a href="/#OC">OC</a>
    &nbsp;&#187;&nbsp;“OC 垃圾回收机制"
    <span class="updated">Updated&nbsp;
    2018-04-02 00:00
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <h1 id="oc">OC 垃圾回收机制</h1>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#oc">OC 垃圾回收机制</a></li>
</ul>
</div>
<blockquote>
<p>1. OC没有垃圾回收机制，而是通过<strong>对象引用计数</strong>进行内存管理，当一个对象的引用计数为零是会自动释放该对象内存。<br />
    2. <strong>ARC</strong>的弊端就是<strong>无法检测到循环引用</strong>的问题，比如父对象有一个对子对象的引用，子对象反过来也引用了父对象，这样他们的引用计数永远也不可能为0.<br />
    3. 需要注意的是OC的内存管理机制<strong>只适用于OC类型的对象，对C语言的数据类型无效</strong>，所有继承自NSObject 的类型都为OC类型<br />
</p>
</blockquote>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2018 .
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://github.com/tankywoo/yasimple_x2" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Site Generated 2018-04-25 17:55:47</p>
      </div> <!-- end footer-right -->
    </div>

    
    
  </body>
</html>