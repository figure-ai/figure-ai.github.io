<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>GCD的使用 - figure-ai的个人wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/">figure-ai的个人wiki</a>
    &nbsp;&#187;&nbsp;
    <a href="/#iOS基础">iOS基础</a>
    &nbsp;&#187;&nbsp;GCD的使用
    <span class="updated">Updated&nbsp;
    2099-06-02 00:00
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <h1 id="gcd">GCD介绍及使用</h1>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#gcd">GCD介绍及使用</a><ul>
<li><a href="#gcd_1">GCD简介</a></li>
<li><a href="#gcd_2">GCD的优势</a></li>
<li><a href="#gcd_3">GCD任务和队列</a><ul>
<li><a href="#_1">任务</a></li>
<li><a href="#_2">队列</a></li>
</ul>
</li>
<li><a href="#gcd_4">GCD的使用步骤</a><ul>
<li><a href="#_3">队列的创建/获取方法</a></li>
<li><a href="#_4">任务的创建方法</a></li>
</ul>
</li>
<li><a href="#gcd_5">GCD的基本使用</a><ul>
<li><a href="#_5">同步执行+并行队列</a></li>
<li><a href="#_6">异步执行+并发队列</a></li>
<li><a href="#_7">同步执行+串行队列</a></li>
<li><a href="#_8">异步执行+串行</a></li>
<li><a href="#_9">同步执行+主队列</a><ul>
<li><a href="#_10">主线程中调用</a></li>
<li><a href="#_11">其他线程调用</a></li>
</ul>
</li>
<li><a href="#_12">异步执行+主队列</a></li>
</ul>
</li>
<li><a href="#gcd_6">GCD线程间的通信</a></li>
<li><a href="#gcd_7">GCD的其他方法</a><ul>
<li><a href="#dispatch_barrier_async">∑dispatch_barrier_async</a></li>
<li><a href="#gcddispatch_after">GCD延时执行方法：dispatch_after</a></li>
<li><a href="#gcddispatch_once">GCD只执行一次代码的方法：dispatch_once</a></li>
<li><a href="#gcddispatch_apply">GCD快速迭代方法：dispatch_apply</a></li>
<li><a href="#gcddispatch_group">GCD队列组：dispatch_group</a><ul>
<li><a href="#dispatch_group_notify">dispatch_group_notify</a></li>
<li><a href="#dispatch_group_wait">dispatch_group_wait</a></li>
<li><a href="#dispatch_group_enterdispatch_group_leave">dispatch_group_enter、dispatch_group_leave</a></li>
</ul>
</li>
<li><a href="#gcddispatch_semaphore">GCD信号量：dispatch_semaphore</a><ul>
<li><a href="#dispatch-semaphore">Dispatch Semaphore 线程同步</a></li>
<li><a href="#dispatch-semaphore_1">Dispatch Semaphore 线程安全（为线程加锁）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_13">参考资料</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="gcd_1">GCD简介</h2>
<blockquote>
<p>GCD全称<strong>Grand Central Dispatch</strong>，是苹果公司为<strong>多核并行运算</strong>提出的解决方案，可以优化应用以支持多核处理器以及其他对称多处理系统。</p>
</blockquote>
<h2 id="gcd_2">GCD的优势</h2>
<ul>
<li>自动利用更多的CPU内核（如：双核、四核）</li>
<li>自动管理线程的生命周期（创建线程、调度任务、销毁线程等，ARC模式下）</li>
<li>自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</li>
</ul>
<h2 id="gcd_3">GCD任务和队列</h2>
<h3 id="_1">任务</h3>
<blockquote>
<p>任务就是线程中要执行的代码，在GCD中是放在block中的，执行任务的方式有两种：<strong>同步执行（sync）和异步执行（async）</strong></p>
</blockquote>
<ol>
<li>
<p><strong>同步执行（sync）</strong></p>
<ul>
<li>不具备开启新线程的能力</li>
<li>在添加的任务执行结束之前，会一直等待，直到任务完成再执行下一个任务。</li>
<li>
<p><strong>异步执行（async）</strong></p>
</li>
<li>
<p>具备开启新线程的能力，但不一定都会开启新线程，更任务所指定的队列类型有关。</p>
</li>
<li>无需等待任务返回，可以继续执行下一个任务，同时执行多个任务。</li>
</ul>
</li>
</ol>
<h3 id="_2">队列</h3>
<blockquote>
<p>用来<strong>存放任务</strong>的等待队列，是一种特殊的线性表，采用FIFO（先进先出）的原则。GCD中有两种队列：<strong>串行队列和并行队列</strong></p>
</blockquote>
<ol>
<li>
<p><strong>串行队列</strong></p>
<ul>
<li>只开启一个线程，按顺序执行，每次只有一个任务被执行，一个任务执行完毕后，再执行下一个任务。</li>
</ul>
</li>
<li>
<p><strong>并发队列</strong></p>
<ul>
<li>可以开启多个线程，并且同时执行多个任务</li>
<li>并发队列的并发功能只有在异步函数下才有效</li>
</ul>
</li>
</ol>
<h2 id="gcd_4">GCD的使用步骤</h2>
<ol>
<li>创建一个队列</li>
<li>创建任务，并将任务追加到队列中，然后系统就会根据任务类型执行任务。</li>
</ol>
<h3 id="_3">队列的创建/获取方法</h3>
<blockquote>
<p>队列可以使用：<code>dispatch_queu_create()</code>来创建，这个函数传入两个参数：<br />
1. 第一个参数表示队列的唯一标识符，用于DEBUG，可为空，（推荐使用应用程序ID这种逆序全程域名）；<br />
2. 第二个参数用来识别是串行（<code>DISPATCH_QUEUE_SERIAL</code>）队列还是并行队列（<code>DISPATCH_QUEUE_CONCURRENT</code>）</p>
</blockquote>
<ol>
<li>
<p>创建串行队列</p>
<p><code>dispatch_queue_t serialQueue = dispatch_queue_create("com.test.ch", DISPATCH_QUEUE_SERIAL);</code></p>
</li>
<li>
<p>创建并行队列</p>
<p><code>dispatch_queue_t crnQueue = dispatch_queue_create("com.test.ch",DISPATCH_QUEUE_CONCURRENT);</code></p>
</li>
<li>
<p>获取主队列<br />
    &gt; 主队列是GCD提供的一种串行队列，所有放在主队列中的任务，都会放到<strong>主线程中执行</strong></p>
<p><code>// 获取主队列
dispatch_queue_t mainQueue = dispatch_get_main_queue();</code><br />
4. 获取全局并发队列（Global Dispatch Queue）</p>
<blockquote>
<p>全局并发队列是GCD提供的一种并发队列。<br />
1. 可以使用<code>dispatch_get_global_queue</code>来获取，需要提供两个参数，第一个设置队列优先级，一般用<code>DISPATSH_QUEUE_PRIORITY_DEFAULT</code>，第二个参数暂时没用，传0即可。</p>
</blockquote>
<p><code>// 获取全局并发队列
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</code></p>
</li>
</ol>
<h3 id="_4">任务的创建方法</h3>
<ol>
<li>
<p>创建同步执行任务</p>
<p><code>// 创建同步执行任务，queue为指定存放任务的队列
dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});</code></p>
</li>
<li>
<p>创建异步执行任务</p>
<p><code>// 创建异步执行任务，queue为指定存放任务的队列
dispatch_async(queue,^{
    // 这里放异步执行任务代码
});</code></p>
</li>
</ol>
<h2 id="gcd_5">GCD的基本使用</h2>
<blockquote>
<p>根据队列类别和任务执行方式GCD的使用有以下几种组合方式。</p>
</blockquote>
<p><img alt="" src="media/15239620421302/15241286723482.jpg" /></p>
<h3 id="_5">同步执行+并行队列</h3>
<blockquote>
<p>在当前线程中执行任务，<strong>不会开启</strong>子线程，任务<strong>有序</strong>执行</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 同步并行</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">syncConcurrent</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;currentThread---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncConcurrent---begin&quot;</span><span class="p">);</span>
    <span class="c1">//创建一个并行队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;sysnc_concurrent_test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>

    <span class="c1">// 添加同步执行任务1</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>    <span class="c1">// 模拟耗时操作</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>      <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>

    <span class="c1">// 添加同步执行任务2</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// 模拟耗时操作</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;2---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>      <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>

    <span class="c1">// 添加同步执行任务2</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">// 模拟耗时操作</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;3---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>      <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncConcurrent--------end&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果<br />
2018-04-19 17:44:08.849921+0800 GCD_Test[8535:933000] currentThread---<NSThread: 0x600000260d00>{number = 1, name = main}<br />
2018-04-19 17:44:08.850056+0800 GCD_Test[8535:933000] syncConcurrent---begin<br />
2018-04-19 17:44:11.851112+0800 GCD_Test[8535:933000] 1---<NSThread: 0x600000260d00>{number = 1, name = main}<br />
2018-04-19 17:44:13.852772+0800 GCD_Test[8535:933000] 2---<NSThread: 0x600000260d00>{number = 1, name = main}<br />
2018-04-19 17:44:14.854313+0800 GCD_Test[8535:933000] 3---<NSThread: 0x600000260d00>{number = 1, name = main}<br />
2018-04-19 17:44:14.854720+0800 GCD_Test[8535:933000] syncConcurrent--------end</p>
</blockquote>
<p>分析：<br />
    1. 因为同步执行不具备开启新线程的能力，所以所有任务都是在<strong>当前线程（主线程）</strong>中执行的。<br />
    2. 因为同步执行需要等上一个任务执行完毕才会执行下一个任务，所以任务会按序执行。</p>
<h3 id="_6">异步执行+并发队列</h3>
<blockquote>
<p>会开启多个线程，任务同时执行</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 异步并行</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">asyncConcurrent</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;currentThread---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;asyncConcurrent---begin&quot;</span><span class="p">);</span>
    <span class="c1">//创建一个并行队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;sysnc_concurrent_test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
    <span class="c1">//添加异步执行任务1</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>    <span class="c1">// 耗时3秒</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1-耗时3秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>      <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>

    <span class="c1">//添加异步执行任务2</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">// 耗时1秒</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2-耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>      <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>

    <span class="c1">//添加异步执行任务3</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// 耗时2秒</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3-耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>      <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncConcurrent--------end&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果：<br />
2018-04-19 17:56:04.424675+0800 GCD_Test[8634:955301] currentThread---<NSThread: 0x600000261a00>{number = 1, name = main}<br />
2018-04-19 17:56:04.424812+0800 GCD_Test[8634:955301] asyncConcurrent---begin<br />
2018-04-19 17:56:04.424926+0800 GCD_Test[8634:955301] syncConcurrent--------end<br />
2018-04-19 17:56:05.425785+0800 GCD_Test[8634:955443] 任务2-耗时1秒--<NSThread: 0x600000471dc0>{number = 4, name = (null)}<br />
2018-04-19 17:56:06.426400+0800 GCD_Test[8634:955439] 任务3-耗时2秒--<NSThread: 0x604000668900>{number = 5, name = (null)}<br />
2018-04-19 17:56:07.427697+0800 GCD_Test[8634:955440] 任务1-耗时3秒--<NSThread: 0x6040002619c0>{number = 6, name = (null)}</p>
</blockquote>
<h3 id="_7">同步执行+串行队列</h3>
<blockquote>
<p>不会开启新线程，只在当前线程执行任务，<strong>按序</strong>执行</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 同步串行</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">syncSerial</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;currentThread---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncSerial---begin&quot;</span><span class="p">);</span>
    <span class="c1">// 创建一个串行队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.lch.test.GCD-Test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
    <span class="c1">// 添加同步任务1</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1--耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加同步任务2</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2--耗时3秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加同步任务3</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3--耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncSerial---end&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果：<br />
2018-04-19 18:05:59.608220+0800 GCD_Test[8736:977132] currentThread---<NSThread: 0x60400007e980>{number = 1, name = main}<br />
2018-04-19 18:05:59.608341+0800 GCD_Test[8736:977132] syncSerial---begin<br />
2018-04-19 18:06:00.608839+0800 GCD_Test[8736:977132] 任务1--耗时1秒--<NSThread: 0x60400007e980>{number = 1, name = main}<br />
2018-04-19 18:06:03.609289+0800 GCD_Test[8736:977132] 任务2--耗时3秒--<NSThread: 0x60400007e980>{number = 1, name = main}<br />
2018-04-19 18:06:05.610914+0800 GCD_Test[8736:977132] 任务3--耗时2秒--<NSThread: 0x60400007e980>{number = 1, name = main}<br />
2018-04-19 18:06:05.611239+0800 GCD_Test[8736:977132] syncSerial---end</p>
</blockquote>
<h3 id="_8">异步执行+串行</h3>
<blockquote>
<p>会<strong>开启一个新线程</strong>，但是因为任务是串行的，所以会按序执行</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 异步串行</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">asyncSerial</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;currentThread---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;asyncSerial---begin&quot;</span><span class="p">);</span>
    <span class="c1">//创建一个串行队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.lch.test.GCD-Test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
    <span class="c1">// 添加异步任务1</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1--耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加异步任务2</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2--耗时3秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加异步任务3</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3--耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;asyncSerial---end&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果：<br />
2018-04-19 18:12:03.514190+0800 GCD_Test[8788:990727] currentThread---<NSThread: 0x60000007a9c0>{number = 1, name = main}<br />
2018-04-19 18:12:03.514312+0800 GCD_Test[8788:990727] asyncSerial---begin<br />
2018-04-19 18:12:03.514409+0800 GCD_Test[8788:990727] asyncSerial---end<br />
2018-04-19 18:12:04.515561+0800 GCD_Test[8788:991002] 任务1--耗时1秒--<NSThread: 0x600000667a40>{number = 5, name = (null)}<br />
2018-04-19 18:12:07.516071+0800 GCD_Test[8788:991002] 任务2--耗时3秒--<NSThread: 0x600000667a40>{number = 5, name = (null)}<br />
2018-04-19 18:12:09.521700+0800 GCD_Test[8788:991002] 任务3--耗时2秒--<NSThread: 0x600000667a40>{number = 5, name = (null)}</p>
</blockquote>
<h3 id="_9">同步执行+主队列</h3>
<h4 id="_10">主线程中调用</h4>
<blockquote>
<p>互相等待，主线程卡死</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 主队列同步执行</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">syncMainQueue</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;currentThread---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncMainQueue---begin&quot;</span><span class="p">);</span>
    <span class="c1">// 获取主队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">mainQueue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
    <span class="c1">//添加同步任务1</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1--耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>

    <span class="c1">// 添加同步任务2</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2--耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加同步任务3</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3--耗时3秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncMainQueue---begin&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h4 id="_11">其他线程调用</h4>
<blockquote>
<p>不会开启新线程，按序执行</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行</span>
    <span class="p">[</span><span class="n">NSThread</span> <span class="n">detachNewThreadSelector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">syncMainQueue</span><span class="p">)</span> <span class="n">toTarget</span><span class="o">:</span><span class="n">self</span> <span class="n">withObject</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</pre></div>


<blockquote>
<p>打印结果<br />
2018-04-19 18:49:13.696441+0800 GCD_Test[9146:1054660] currentThread---<NSThread: 0x604000466c40>{number = 5, name = (null)}<br />
2018-04-19 18:49:13.696600+0800 GCD_Test[9146:1054660] syncMainQueue---begin<br />
2018-04-19 18:49:14.702150+0800 GCD_Test[9146:1054248] 任务1--耗时1秒--<NSThread: 0x604000079880>{number = 1, name = main}<br />
2018-04-19 18:49:17.705675+0800 GCD_Test[9146:1054248] 任务2--耗时2秒--<NSThread: 0x604000079880>{number = 1, name = main}<br />
2018-04-19 18:49:19.727515+0800 GCD_Test[9146:1054248] 任务3--耗时3秒--<NSThread: 0x604000079880>{number = 1, name = main}<br />
2018-04-19 18:49:19.727875+0800 GCD_Test[9146:1054660] syncMainQueue---begin</p>
</blockquote>
<h3 id="_12">异步执行+主队列</h3>
<blockquote>
<p>只在主线程中执行任务，执行完一个再执行下一个</p>
</blockquote>
<div class="hlcode"><pre><span class="c1">// 主队列异步执行</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">asyncMainQueue</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;currentThread---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;asyncMainQueue---begin&quot;</span><span class="p">);</span>
    <span class="c1">// 获取主队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">mainQueue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1--耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2--耗时3秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3--耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;syncMainQueue---begin&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果<br />
2018-04-19 18:57:09.221843+0800 GCD_Test[9199:1069120] currentThread---<NSThread: 0x604000067bc0>{number = 1, name = main}<br />
2018-04-19 18:57:09.221979+0800 GCD_Test[9199:1069120] asyncMainQueue---begin<br />
2018-04-19 18:57:09.222149+0800 GCD_Test[9199:1069120] syncMainQueue---begin<br />
2018-04-19 18:57:10.229029+0800 GCD_Test[9199:1069120] 任务1--耗时1秒--<NSThread: 0x604000067bc0>{number = 1, name = main}<br />
2018-04-19 18:57:13.230537+0800 GCD_Test[9199:1069120] 任务2--耗时3秒--<NSThread: 0x604000067bc0>{number = 1, name = main}<br />
2018-04-19 18:57:14.232182+0800 GCD_Test[9199:1069120] 任务3--耗时2秒--<NSThread: 0x604000067bc0>{number = 1, name = main}</p>
</blockquote>
<h2 id="gcd_6">GCD线程间的通信</h2>
<blockquote>
<p>使用场景：比如在子线程下载数据，然后到主线程刷新界面</p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">queueCommunication</span> <span class="p">{</span>
    <span class="c1">// 获取global队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">globalQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 获取主队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">mainQueue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//处理耗时操作</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;--处理耗时操作---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;--回到主线程--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果：<br />
2018-04-19 19:09:30.741262+0800 GCD_Test[9314:1094783] --处理耗时操作---<NSThread: 0x600000474240>{number = 5, name = (null)}<br />
2018-04-19 19:09:30.741861+0800 GCD_Test[9314:1094724] --回到主线程--<NSThread: 0x60000007c1c0>{number = 1, name = main}</p>
</blockquote>
<h2 id="gcd_7">GCD的其他方法</h2>
<h3 id="dispatch_barrier_async">∑dispatch_barrier_async</h3>
<blockquote>
<p><code>dispatch_barrier_async()</code>方法：<strong>先执行栅栏前的任务，然后在执行栅栏中的任务，再执行栅栏后的任务</strong></p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">barrierAsync</span> <span class="p">{</span>
    <span class="c1">// 创建一个并行队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">concurrent</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.lch.test.GCD-Test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
    <span class="c1">// 追加异步任务1</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrent</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
       <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1---耗时3秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 追加异步任务2</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrent</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2---耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加栅栏</span>
    <span class="n">dispatch_barrier_sync</span><span class="p">(</span><span class="n">concurrent</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;栅栏---耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 追加异步任务3</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrent</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3---耗时1秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 添加栅栏</span>
    <span class="n">dispatch_barrier_sync</span><span class="p">(</span><span class="n">concurrent</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;栅栏---耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>

    <span class="c1">// 追加异步任务4</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrent</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">//</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务4---耗时2秒--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果：<br />
2018-04-20 11:58:30.231174+0800 GCD_Test[10572:1359087] 任务2---耗时1秒--<NSThread: 0x600000279600>{number = 3, name = (null)}<br />
2018-04-20 11:58:32.232077+0800 GCD_Test[10572:1359090] 任务1---耗时3秒--<NSThread: 0x60000047bd80>{number = 5, name = (null)}<br />
2018-04-20 11:58:34.233081+0800 GCD_Test[10572:1359006] 栅栏---耗时2秒--<NSThread: 0x600000071340>{number = 1, name = main}<br />
2018-04-20 11:58:35.235600+0800 GCD_Test[10572:1359090] 任务3---耗时1秒--<NSThread: 0x60000047bd80>{number = 5, name = (null)}<br />
2018-04-20 11:58:37.237299+0800 GCD_Test[10572:1359006] 栅栏---耗时2秒--<NSThread: 0x600000071340>{number = 1, name = main}<br />
2018-04-20 11:58:39.237854+0800 GCD_Test[10572:1359090] 任务4---耗时2秒--<NSThread: 0x60000047bd80>{number = 5, name = (null)}</p>
</blockquote>
<h3 id="gcddispatch_after">GCD延时执行方法：dispatch_after</h3>
<blockquote>
<p><code>dispatch_after</code> :可以设定多长时间后执行任务<br />
需要注意的是：函数并不是在指定时间后才开始执行，而是爱指定时间之后将任务追加到主队列，严格来说这个时间并不是绝对准确。</p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">afterAsync</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;after----begin----&quot;</span><span class="p">);</span>
    <span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// 2.0秒后异步追加任务代码到主队列，并开始执行</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;after---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>  <span class="c1">// 打印当前线程</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;after----end----&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果<br />
2018-04-20 14:24:19.624885+0800 GCD_Test[11324:1481815] after----begin----<br />
2018-04-20 14:24:19.625034+0800 GCD_Test[11324:1481815] after----end----<br />
2018-04-20 14:24:21.738247+0800 GCD_Test[11324:1481815] after---<NSThread: 0x60000006fdc0>{number = 1, name = main}</p>
</blockquote>
<h3 id="gcddispatch_once">GCD只执行一次代码的方法：dispatch_once</h3>
<blockquote>
<p>创建<strong>单例</strong>或者有整个程序运行过程中只执行一次的代码时可以用此方法，<code>dispatch_once</code>可以保证代码在程序运行过程中只执行一次，几时在多线程环境下，也可以保证线程安全。</p>
</blockquote>
<div class="hlcode"><pre><span class="cp">#pragma mark - GCD只执行一次代码的方法：dispatch_once</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">gcdOnce</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----我只会执行一次----&quot;</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>


<h3 id="gcddispatch_apply">GCD快速迭代方法：dispatch_apply</h3>
<blockquote>
<p><code>dispatch_apply</code>： 可以开启多个线程进行遍历，这在遍历数组上可以起到优化的作用，而且<code>dispatch_apply</code>会等全部任务执行完毕再继续执行后面的操作</p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">gcdApply</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----apply--begin----&quot;</span><span class="p">);</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">globalQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dispatch_apply</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">objArray</span> <span class="n">count</span><span class="p">],</span> <span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;-----%zd----%@&quot;</span><span class="p">,</span><span class="n">index</span><span class="p">,</span> <span class="p">[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----apply--end----&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>2018-04-20 16:22:22.181731+0800 GCD_Test[12647:1694230] ----apply--begin----<br />
2018-04-20 16:22:22.181958+0800 GCD_Test[12647:1694230] -----0----<NSThread: 0x600000068840>{number = 1, name = main}<br />
2018-04-20 16:22:22.182013+0800 GCD_Test[12647:1694425] -----2----<NSThread: 0x604000264a80>{number = 3, name = (null)}<br />
2018-04-20 16:22:22.182036+0800 GCD_Test[12647:1694427] -----3----<NSThread: 0x60000047fbc0>{number = 5, name = (null)}<br />
2018-04-20 16:22:22.182038+0800 GCD_Test[12647:1694428] -----1----<NSThread: 0x6000004660c0>{number = 4, name = (null)}<br />
2018-04-20 16:22:22.182131+0800 GCD_Test[12647:1694230] -----4----<NSThread: 0x600000068840>{number = 1, name = main}<br />
2018-04-20 16:22:22.182305+0800 GCD_Test[12647:1694427] -----6----<NSThread: 0x60000047fbc0>{number = 5, name = (null)}<br />
2018-04-20 16:22:22.182306+0800 GCD_Test[12647:1694425] -----5----<NSThread: 0x604000264a80>{number = 3, name = (null)}<br />
2018-04-20 16:22:22.182341+0800 GCD_Test[12647:1694428] -----7----<NSThread: 0x6000004660c0>{number = 4, name = (null)}<br />
2018-04-20 16:22:22.182380+0800 GCD_Test[12647:1694230] -----8----<NSThread: 0x600000068840>{number = 1, name = main}<br />
2018-04-20 16:22:22.182465+0800 GCD_Test[12647:1694425] -----9----<NSThread: 0x604000264a80>{number = 3, name = (null)}<br />
2018-04-20 16:22:22.183692+0800 GCD_Test[12647:1694230] ----apply--end----</p>
</blockquote>
<h3 id="gcddispatch_group">GCD队列组：dispatch_group</h3>
<blockquote>
<p><code>dispatch_group</code>：GCD的队列组，可以调用<code>dispatch_group_async()</code>方法添加任务，然后按组执行</p>
</blockquote>
<h4 id="dispatch_group_notify">dispatch_group_notify</h4>
<blockquote>
<p>监听group中任务的完成状态，当组中所有任务完成是，调用<code>dispatch_group_notify</code>中的代码</p>
</blockquote>
<div class="hlcode"><pre><span class="cp">#pragma mark - GCD任务组：dispatch_group_notify</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">groupNotify</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---group-begin--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="c1">// 创建一个队列组</span>
    <span class="kt">dispatch_group_t</span> <span class="n">queueGroup</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
    <span class="c1">// 获取全局队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">globalQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 向队列组追加任务1</span>
    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---任务1--耗时2秒---&quot;</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---任务2--耗时1秒---&quot;</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="c1">//组中任务完成后再回到主线程调用</span>
    <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---group-end--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>2018-04-20 16:38:44.548952+0800 GCD_Test[12770:1725716] ---group-begin--<NSThread: 0x600000064000>{number = 1, name = main}<br />
2018-04-20 16:38:46.552524+0800 GCD_Test[12770:1725781] ---任务2--耗时1秒---<br />
2018-04-20 16:38:46.552524+0800 GCD_Test[12770:1725782] ---任务1--耗时2秒---<br />
2018-04-20 16:38:46.552835+0800 GCD_Test[12770:1725716] ---group-end--<NSThread: 0x600000064000>{number = 1, name = main}</p>
</blockquote>
<h4 id="dispatch_group_wait">dispatch_group_wait</h4>
<blockquote>
<p>暂停阻塞当前线程，等待指定的group中完成任务后再继续往下执行。</p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">groupWait</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----wait---begin---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="c1">//创建一个队列组</span>
    <span class="kt">dispatch_group_t</span> <span class="n">queueGroup</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
    <span class="c1">// 获取全局队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">globalQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">4</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---任务1--耗时4秒---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---任务2--耗时1秒---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="c1">// 传-1需要等待，传0不需等待直接执行后面代码</span>
    <span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----wait---end---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>2018-04-20 16:54:41.180500+0800 GCD_Test[12970:1757380] ----wait---begin---<NSThread: 0x604000079140>{number = 1, name = main}<br />
2018-04-20 16:54:42.181933+0800 GCD_Test[12970:1757447] ---任务2--耗时1秒---<NSThread: 0x604000276180>{number = 3, name = (null)}<br />
2018-04-20 16:54:45.182507+0800 GCD_Test[12970:1757448] ---任务1--耗时4秒---<NSThread: 0x60400027f640>{number = 4, name = (null)}<br />
2018-04-20 16:54:45.183019+0800 GCD_Test[12970:1757380] ----wait---end---<NSThread: 0x604000079140>{number = 1, name = main}</p>
</blockquote>
<h4 id="dispatch_group_enterdispatch_group_leave">dispatch_group_enter、dispatch_group_leave</h4>
<blockquote>
<p><code>dispatch_group_enter</code>类似于<strong>对象引用计数</strong>的<code>retain</code>每调用一次group的引用计数加一，<code>dispatch_group_leave</code>类似于<strong>对象引用计数</strong>的<code>release</code>没调用一次引用计数减一，当引用计数为0时，<code>dispatch_group_wait</code>会解除，然后调用<code>dispatch_group_notify</code><br />
<code>dispatch_group_enter、dispatch_group_leave</code>的组合使用其实相当于<code>dispatch_group_async</code></p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enterLeave</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;--enter--begin--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="c1">// 创建一个队列组</span>
    <span class="kt">dispatch_group_t</span> <span class="n">queueGroup</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
    <span class="c1">// 获取全局队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">globalQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">);</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---任务1--耗时3秒---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
        <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">);</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">globalQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---任务2--耗时1秒---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
        <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----notify---end---%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="p">});</span>
    <span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">queueGroup</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----wait--end--%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>2018-04-20 17:21:27.634479+0800 GCD_Test[13266:1816278] --enter--begin--<NSThread: 0x60400007ef00>{number = 1, name = main}<br />
2018-04-20 17:21:28.639462+0800 GCD_Test[13266:1816382] ---任务2--耗时1秒---<NSThread: 0x600000279140>{number = 4, name = (null)}<br />
2018-04-20 17:21:30.638860+0800 GCD_Test[13266:1816380] ---任务1--耗时3秒---<NSThread: 0x60400047fe00>{number = 5, name = (null)}<br />
2018-04-20 17:21:30.639271+0800 GCD_Test[13266:1816278] ----wait--end--<NSThread: 0x60400007ef00>{number = 1, name = main}<br />
2018-04-20 17:21:30.672949+0800 GCD_Test[13266:1816278] ----notify---end---<NSThread: 0x60400007ef00>{number = 1, name = main}</p>
</blockquote>
<h3 id="gcddispatch_semaphore">GCD信号量：dispatch_semaphore</h3>
<blockquote>
<p>GCD中的信号量是指<strong>Dispatch Semaphore</strong>，是持有计数的信号，编程人员可以通过控制<code>dispatch_semaphore_t</code>的信号计数，从而<strong>控制线程代码的执行</strong></p>
</blockquote>
<ul>
<li>
<p>使用场景</p>
<ol>
<li><strong>保持线程同步，将异步执行任务转到同步执行</strong></li>
<li><strong>保证线程安全，为线程加锁</strong></li>
</ol>
</li>
<li>
<p><code>dispatch_semaphore</code>主要有三个函数：</p>
<ul>
<li><code>dispatch_semaphore_create(long value)</code>：初始化信号计数并返回一个<code>dispatch_semaphore_t</code>信号量</li>
<li><code>dispatch_semphore_signal</code>：发送一个信号，让信号总量加1</li>
<li><code>dispatch_semphore_wait</code>：当信号量为0时会一直等待（阻塞当前线程），否则正常运行，每运行一次会使信号总量减一。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：<strong>如果主线程调用时，可能会一直阻塞主线程</strong>，所以在使用<code>dispatch_semaphore</code>前，一定要清楚自己操作的是哪个线程</p>
</blockquote>
<h4 id="dispatch-semaphore">Dispatch Semaphore 线程同步</h4>
<blockquote>
<p>比如：AFNetworking中的AFURLSessionManager.m里面的taskForKeyPath：方法，通过引入信号量的方式，等待异步执行结果，获取到tasks然后再做返回</p>
</blockquote>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">tasksForKeyPath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">tasks</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="kt">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="n">getTasksWithCompletionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">dataTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">uploadTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="n">isEqualToString</span><span class="o">:</span><span class="n">NSStringFromSelector</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">dataTasks</span><span class="p">))])</span> <span class="p">{</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="n">dataTasks</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="n">isEqualToString</span><span class="o">:</span><span class="n">NSStringFromSelector</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">uploadTasks</span><span class="p">))])</span> <span class="p">{</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="n">uploadTasks</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="n">isEqualToString</span><span class="o">:</span><span class="n">NSStringFromSelector</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">downloadTasks</span><span class="p">))])</span> <span class="p">{</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="n">downloadTasks</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="n">isEqualToString</span><span class="o">:</span><span class="n">NSStringFromSelector</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">tasks</span><span class="p">))])</span> <span class="p">{</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="err">@</span><span class="p">[</span><span class="n">dataTasks</span><span class="p">,</span> <span class="n">uploadTasks</span><span class="p">,</span> <span class="n">downloadTasks</span><span class="p">]</span> <span class="n">valueForKeyPath</span><span class="o">:</span><span class="s">@&quot;@unionOfArrays.self&quot;</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
    <span class="p">}];</span>

    <span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">tasks</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="dispatch-semaphore_1">Dispatch Semaphore 线程安全（为线程加锁）</h4>
<blockquote>
<p>当多个线程访问<strong>同一个类（方法、或对象）</strong>，这个类始终能<strong>表现出正确的行为</strong>，那么这个类就是线程安全的。</p>
</blockquote>
<ul>
<li>
<p>比如：有10张火车票，两个售卖火车票的窗口，一个是北京窗口，一个是上海窗口。两个窗口同时售卖火车票，卖完为止。</p>
</li>
<li>
<p>在不考虑线程安全的情况下，代码如下：</p>
</li>
</ul>
<div class="hlcode"><pre><span class="cp">#pragma mark - 不考虑线程安全的情况</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">shopTick</span> <span class="p">{</span>
<span class="c1">//    NSLog(@&quot;----0000----%@&quot;,[NSThread currentThread]);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----00000------%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="n">self</span><span class="p">.</span><span class="n">tickCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// 创建上海队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">shangHai</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.Test.ShangHai&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
    <span class="c1">// 创建背景队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">beiJing</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.Test.Beijing&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
    <span class="c1">//卖票</span>
    <span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">shangHai</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">weakSelf</span> <span class="n">shop</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">beiJing</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">weakSelf</span> <span class="n">shop</span><span class="p">];</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 模拟售票</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">shop</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tickCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//如果还有票，继续售卖</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tickCount</span><span class="o">--</span><span class="p">;</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">stringWithFormat</span><span class="o">:</span><span class="s">@&quot;剩余票数：%d 窗口：%@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">tickCount</span><span class="p">,</span> <span class="p">[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]]);</span>
            <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mf">0.2</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//如果已卖完，关闭售票窗口</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;所有火车票均已售完&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>打印结果：<br />
2018-04-21 16:29:18.566294+0800 GCD_Test[20249:2807585] ----00000------<NSThread: 0x60400007d800>{number = 1, name = main}<br />
2018-04-21 16:29:18.566609+0800 GCD_Test[20249:2807784] 剩余票数：9 窗口：<NSThread: 0x600000475480>{number = 3, name = (null)}<br />
2018-04-21 16:29:18.566615+0800 GCD_Test[20249:2807785] 剩余票数：8 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:18.768913+0800 GCD_Test[20249:2807784] 剩余票数：7 窗口：<NSThread: 0x600000475480>{number = 3, name = (null)}<br />
2018-04-21 16:29:18.768913+0800 GCD_Test[20249:2807785] 剩余票数：6 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:18.972331+0800 GCD_Test[20249:2807784] 剩余票数：5 窗口：<NSThread: 0x600000475480>{number = 3, name = (null)}<br />
2018-04-21 16:29:18.972333+0800 GCD_Test[20249:2807785] 剩余票数：5 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:19.175883+0800 GCD_Test[20249:2807784] 剩余票数：3 窗口：<NSThread: 0x600000475480>{number = 3, name = (null)}<br />
2018-04-21 16:29:19.175888+0800 GCD_Test[20249:2807785] 剩余票数：4 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:19.380030+0800 GCD_Test[20249:2807785] 剩余票数：2 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:19.380030+0800 GCD_Test[20249:2807784] 剩余票数：2 窗口：<NSThread: 0x600000475480>{number = 3, name = (null)}<br />
2018-04-21 16:29:19.584104+0800 GCD_Test[20249:2807784] 剩余票数：1 窗口：<NSThread: 0x600000475480>{number = 3, name = (null)}<br />
2018-04-21 16:29:19.584104+0800 GCD_Test[20249:2807785] 剩余票数：1 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:19.789115+0800 GCD_Test[20249:2807784] 所有火车票均已售完<br />
2018-04-21 16:29:19.789121+0800 GCD_Test[20249:2807785] 剩余票数：0 窗口：<NSThread: 0x6000004753c0>{number = 4, name = (null)}<br />
2018-04-21 16:29:19.992451+0800 GCD_Test[20249:2807785] 所有火车票均已售完</p>
</blockquote>
<ul>
<li>考虑线程安全的情况下</li>
</ul>
<div class="hlcode"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">shopTick</span> <span class="p">{</span>
<span class="c1">//    NSLog(@&quot;----0000----%@&quot;,[NSThread currentThread]);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----00000------%@&quot;</span><span class="p">,[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
    <span class="n">self</span><span class="p">.</span><span class="n">tickCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// 初始化信号量</span>
    <span class="n">_semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 创建上海队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">shangHai</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.Test.ShangHai&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
    <span class="c1">// 创建背景队列</span>
    <span class="kt">dispatch_queue_t</span> <span class="n">beiJing</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.Test.Beijing&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
    <span class="c1">//卖票</span>
    <span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">shangHai</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">weakSelf</span> <span class="n">shop</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">beiJing</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">weakSelf</span> <span class="n">shop</span><span class="p">];</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 模拟售票</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">shop</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 加锁，可以理解为如果正在售票则进行等待</span>
        <span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">_semaphore</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tickCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//如果还有票，继续售卖</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tickCount</span><span class="o">--</span><span class="p">;</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">stringWithFormat</span><span class="o">:</span><span class="s">@&quot;剩余票数：%d 窗口：%@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">tickCount</span><span class="p">,</span> <span class="p">[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]]);</span>
            <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mf">0.2</span><span class="p">];</span>
            <span class="c1">//执行完一次售票操作，解锁</span>
            <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">_semaphore</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//如果已卖完，关闭售票窗口</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;所有火车票均已售完&quot;</span><span class="p">);</span>
            <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">_semaphore</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<p>执行结果<br />
2018-04-21 17:22:01.462763+0800 GCD_Test[20462:2845077] ----00000------<NSThread: 0x60000006cdc0>{number = 1, name = main}<br />
2018-04-21 17:22:01.463025+0800 GCD_Test[20462:2845298] 剩余票数：9 窗口：<NSThread: 0x60400026d800>{number = 3, name = (null)}<br />
2018-04-21 17:22:01.667396+0800 GCD_Test[20462:2845296] 剩余票数：8 窗口：<NSThread: 0x60400026de00>{number = 4, name = (null)}<br />
2018-04-21 17:22:01.870932+0800 GCD_Test[20462:2845298] 剩余票数：7 窗口：<NSThread: 0x60400026d800>{number = 3, name = (null)}<br />
2018-04-21 17:22:02.073737+0800 GCD_Test[20462:2845296] 剩余票数：6 窗口：<NSThread: 0x60400026de00>{number = 4, name = (null)}<br />
2018-04-21 17:22:02.278715+0800 GCD_Test[20462:2845298] 剩余票数：5 窗口：<NSThread: 0x60400026d800>{number = 3, name = (null)}<br />
2018-04-21 17:22:02.482867+0800 GCD_Test[20462:2845296] 剩余票数：4 窗口：<NSThread: 0x60400026de00>{number = 4, name = (null)}<br />
2018-04-21 17:22:02.686127+0800 GCD_Test[20462:2845298] 剩余票数：3 窗口：<NSThread: 0x60400026d800>{number = 3, name = (null)}<br />
2018-04-21 17:22:02.887050+0800 GCD_Test[20462:2845296] 剩余票数：2 窗口：<NSThread: 0x60400026de00>{number = 4, name = (null)}<br />
2018-04-21 17:22:03.091466+0800 GCD_Test[20462:2845298] 剩余票数：1 窗口：<NSThread: 0x60400026d800>{number = 3, name = (null)}<br />
2018-04-21 17:22:03.295766+0800 GCD_Test[20462:2845296] 剩余票数：0 窗口：<NSThread: 0x60400026de00>{number = 4, name = (null)}<br />
2018-04-21 17:22:03.499228+0800 GCD_Test[20462:2845298] 所有火车票均已售完<br />
2018-04-21 17:22:03.499457+0800 GCD_Test[20462:2845296] 所有火车票均已售完</p>
</blockquote>
<h2 id="_13">参考资料</h2>
<blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/77c5051aede2">GCD-使用总结</a></li>
<li><a href="https://www.jianshu.com/p/2d57c72016c6">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="https://developer.apple.com/documentation/dispatch?language=objc">GCD官方文档</a></li>
<li><a href="https://www.jianshu.com/p/a84c2bf0d77b">iOS GCD之dispatch_semaphore学习</a></li>
</ul>
</blockquote>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2018 figure-ai.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://github.com/tankywoo/yasimple_x2" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Site Generated 2018-04-25 15:58:01</p>
      </div> <!-- end footer-right -->
    </div>

    
    
  </body>
</html>